<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mAIware Server Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="styles.css?v=3.0">
    <!-- Add Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <!-- Add Leaflet.js for maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Add Leaflet Heatmap Plugin -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <!-- Add D3.js for force-directed graph -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Add html2canvas for screenshots -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body>
    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()">
        <span class="icon" id="themeIcon">üåô</span>
        <span id="themeText">Dark</span>
    </button>

    <!-- Back to Top Button -->
    <button class="back-to-top" id="backToTop" onclick="scrollToTop()">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- Preview Backdrop -->
    <div class="preview-backdrop" id="previewBackdrop"></div>

    <!-- Side Navigation Panel -->
    <div class="side-panel" id="sidePanel">
        <!-- Logo Icon (always visible) -->
        <div class="panel-icon-strip">
            <div class="panel-logo-icon">
                <i class="fas fa-shield-virus"></i>
            </div>
        </div>
        
        <!-- Analytics Preview Panel (slides out on hover) -->
        <div class="graphs-preview" id="graphsPreview">
            <div class="preview-header">
                <h3><i class="fas fa-chart-line"></i> Analytics Preview</h3>
                <p>Click anywhere to view full analytics</p>
            </div>
            
            <!-- Scaled-down live view of analytics -->
            <div class="analytics-miniview" id="analyticsMiniview" onclick="switchView('analytics')">
                <div class="miniview-preview">
                    <div class="preview-row">
                        <div class="preview-box large">
                            <div class="box-header">Global Threat Map</div>
                            <div class="box-content map-visual">
                                <div class="map-dot" style="top: 30%; left: 40%;"></div>
                                <div class="map-dot" style="top: 60%; left: 70%;"></div>
                                <div class="map-dot" style="top: 45%; left: 25%;"></div>
                            </div>
                        </div>
                        <div class="preview-box large">
                            <div class="box-header">Attack Timeline</div>
                            <div class="box-content chart-visual">
                                <div class="chart-bar" style="height: 40%;"></div>
                                <div class="chart-bar" style="height: 70%;"></div>
                                <div class="chart-bar" style="height: 55%;"></div>
                                <div class="chart-bar" style="height: 85%;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-box">
                            <div class="box-header">Top Threats</div>
                            <div class="box-content list-visual">
                                <div class="list-item"></div>
                                <div class="list-item"></div>
                                <div class="list-item"></div>
                            </div>
                        </div>
                        <div class="preview-box">
                            <div class="box-header">Correlations</div>
                            <div class="box-content network-visual">
                                <div class="network-node" style="top: 30%; left: 30%;"></div>
                                <div class="network-node" style="top: 60%; left: 50%;"></div>
                                <div class="network-node" style="top: 45%; left: 70%;"></div>
                            </div>
                        </div>
                        <div class="preview-box">
                            <div class="box-header">Heatmap</div>
                            <div class="box-content heat-visual"></div>
                        </div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-box wide">
                            <div class="box-header">File Analysis & Distribution</div>
                            <div class="box-content pie-visual">
                                <div class="pie-chart"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="miniview-overlay">
                    <i class="fas fa-expand-alt"></i>
                    <span>Click to view analytics</span>
                </div>
            </div>                <!-- Home Navigation Button -->
                <div class="preview-home-nav" id="homeNavBtn" onclick="switchView('dashboard')">
                    <i class="fas fa-home"></i>
                    <span>Back to Dashboard</span>
                </div>
            </div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <!-- DASHBOARD VIEW -->
        <div class="view-container active" id="dashboardView">
            <header class="dashboard-header">
                <div class="header-content">
                    <h1><i class="fas fa-shield-virus pulse-icon"></i> mAIware Server</h1>
                    <p class="subtitle">Real-time Malware Analysis Dashboard</p>
                </div>
            </header>
            
            <!-- Real-time Threat Ticker -->
            <div class="threat-ticker-container animate-slide-in">
                <div class="ticker-label">
                    <i class="fas fa-broadcast-tower pulse-icon"></i>
                    <span>LIVE THREAT FEED</span>
                </div>
                <div class="threat-ticker" id="threat-ticker">
                    <div class="ticker-content" id="ticker-content">
                        <span class="ticker-item">System ready - Monitoring for threats...</span>
                    </div>
                </div>
            </div>
            
            <!-- Notification Toast Container -->
            <div id="notification-container" class="notification-container"></div>
            
            <!-- Stats Grid -->
            <div class="stats-grid animate-fade-in" id="stats-grid">
                <div class="stat-card info">
                    <i class="fas fa-laptop"></i>
                    <span class="stat-number" id="stat-clients">0</span>
                    <span class="stat-label">Active Clients</span>
                    <div class="stat-glow"></div>
                </div>
                <div class="stat-card info">
                    <i class="fas fa-chart-line"></i>
                    <span class="stat-number" id="stat-total">0</span>
                    <span class="stat-label">Total Scans</span>
                    <div class="stat-glow"></div>
                </div>
                <div class="stat-card malware">
                    <i class="fas fa-bug"></i>
                    <span class="stat-number" id="stat-malware">0</span>
                    <span class="stat-label">Malware</span>
                    <div class="stat-glow"></div>
                </div>
                <div class="stat-card suspicious">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span class="stat-number" id="stat-suspicious">0</span>
                    <span class="stat-label">Suspicious</span>
                    <div class="stat-glow"></div>
                </div>
                <div class="stat-card benign">
                    <i class="fas fa-check-circle"></i>
                    <span class="stat-number" id="stat-benign">0</span>
                    <span class="stat-label">Benign</span>
                    <div class="stat-glow"></div>
                </div>
                <div class="stat-card info">
                    <i class="fas fa-eye"></i>
                    <span class="stat-number" id="stat-site-visits">0</span>
                    <span class="stat-label">Site Visits (All-time)</span>
                    <div class="stat-glow"></div>
                </div>
            </div>
            
            <!-- Recent Scans -->
            <div class="scans-container animate-fade-in">
                <div class="scans-header">
                    <h2><i class="fas fa-list"></i> Recent Scans</h2>
                    <button class="refresh-btn" onclick="manualRefresh()">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
                
                <table class="scans-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Filename</th>
                            <th>Classification</th>
                            <th>Client IP</th>
                            <th>Hash (SHA256)</th>
                        </tr>
                    </thead>
                    <tbody id="scans-tbody">
                        <tr>
                            <td colspan="5" class="empty-state">
                                <i class="fas fa-inbox"></i>
                                <p>No scans yet. Waiting for clients...</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- ANALYTICS VIEW -->
        <div class="view-container" id="analyticsView">
            <div class="analytics-header">
                <button class="back-btn" onclick="switchView('dashboard')">
                    <i class="fas fa-arrow-left"></i> Back to Dashboard
                </button>
                <h1><i class="fas fa-chart-line"></i> Analytics & Intelligence</h1>
            </div>
            
            <div class="analytics-grid" id="analyticsGrid">
                
                <!-- Daily Analysis Chart -->
                <div class="chart-container analytics-panel panel-large">
                    <div class="chart-header">
                        <h2><i class="fas fa-chart-line"></i> Daily Analysis Trends</h2>
                        <div class="chart-controls">
                            <button class="chart-btn active" onclick="setChartDays(7)">7 Days</button>
                            <button class="chart-btn" onclick="setChartDays(14)">14 Days</button>
                            <button class="chart-btn" onclick="setChartDays(30)">30 Days</button>
                        </div>
                    </div>
                    <canvas id="dailyScansChart"></canvas>
                </div>
                    <canvas id="dailyScansChart"></canvas>
                </div>

                <!-- Geographic Threat Intelligence Map -->
                <div class="map-container analytics-panel panel-large">
                    <div class="map-header">
                        <h2><i class="fas fa-globe-americas"></i> Global Threat Intelligence Map</h2>
                        <div class="map-controls">
                            <div class="map-view-toggle">
                                <button class="map-btn active" data-view="markers" onclick="switchMapView('markers')">
                                    <i class="fas fa-map-marker-alt"></i> Markers
                                </button>
                                <button class="map-btn" data-view="heatmap" onclick="switchMapView('heatmap')">
                                    <i class="fas fa-fire"></i> Heatmap
                                </button>
                                <button class="map-btn" data-view="choropleth" onclick="switchMapView('choropleth')">
                                    <i class="fas fa-globe"></i> Choropleth
                                </button>
                            </div>
                            <div class="map-legend">
                                <span class="legend-item"><span class="legend-dot malware-dot"></span> Malware</span>
                                <span class="legend-item"><span class="legend-dot suspicious-dot"></span> Suspicious</span>
                                <span class="legend-item"><span class="legend-dot benign-dot"></span> Benign</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Geographic Context Panel -->
                    <div class="geo-context-panel" id="geoContext">
                        <div class="context-stat">
                            <span class="context-label">Active Regions:</span>
                            <span class="context-value" id="activeRegions">0</span>
                        </div>
                        <div class="context-stat">
                            <span class="context-label">Hotspot:</span>
                            <span class="context-value" id="topRegion">None</span>
                        </div>
                        <div class="context-stat">
                            <span class="context-label">Total Threats:</span>
                            <span class="context-value threat-count" id="geoThreatCount">0</span>
                        </div>
                    </div>
                    
                    <div id="worldMap" style="height: 500px; border-radius: 8px; margin-bottom: 15px;"></div>
                    
                    <!-- Timeline Control -->
                    <div class="map-timeline-control">
                        <button class="timeline-btn" onclick="replayThreats()" id="replayBtn">
                            <i class="fas fa-play"></i> Replay Last 24h
                        </button>
                        <div class="timeline-info" id="timelineInfo">
                            Click replay to see threat propagation over time
                        </div>
                    </div>
                </div>

                <!-- Malware Source Distribution -->
                <div class="chart-container analytics-panel panel-small">
                    <div class="chart-header">
                        <h2><i class="fas fa-chart-pie"></i> Malware Source Distribution</h2>
                    </div>
                    <div style="max-width: 500px; margin: 0 auto;">
                        <canvas id="malwareSourceChart"></canvas>
                    </div>
                </div>

                <!-- Graph 2: "Noisiest" Agents Over Time -->
                <div class="chart-container analytics-panel panel-large">
                    <div class="chart-header">
                        <h2><i class="fas fa-desktop"></i> "Noisiest" Agents Over Time</h2>
                        <p class="chart-subtitle">Threat detection trends for top 5 high-risk agents</p>
                    </div>
                    <div style="height: 300px;">
                        <canvas id="noisyAgentsChart"></canvas>
                    </div>
                </div>

                <!-- Advanced Analytics Grid -->
                <div class="analytics-panel panel-large advanced-analytics-grid">
                    <div class="chart-header">
                        <h2><i class="fas fa-chart-area"></i> Advanced Statistical Analysis</h2>
                        <p class="chart-subtitle">Deep dive into signature verification, packer usage, AI confidence, and entropy patterns</p>
                    </div>
                    
                    <div class="mini-charts-grid">
                        <!-- Graph 3: Signature Status vs. Classification -->
                        <div class="mini-chart-container">
                            <h3><i class="fas fa-certificate"></i> Signature vs. Classification</h3>
                            <div style="height: 200px;">
                                <canvas id="signatureClassChart"></canvas>
                            </div>
                        </div>

                        <!-- Graph 4: Packer Usage vs. Classification -->
                        <div class="mini-chart-container">
                            <h3><i class="fas fa-box"></i> Packer vs. Classification</h3>
                            <div style="height: 200px;">
                                <canvas id="packerClassChart"></canvas>
                            </div>
                        </div>

                        <!-- Graph 5: Confidence Score Distribution -->
                        <div class="mini-chart-container">
                            <h3><i class="fas fa-brain"></i> AI Confidence Distribution</h3>
                            <div style="height: 200px;">
                                <canvas id="confidenceHistChart"></canvas>
                            </div>
                        </div>

                        <!-- Graph 6: File Entropy Distribution -->
                        <div class="mini-chart-container">
                            <h3><i class="fas fa-chart-bar"></i> Entropy Distribution</h3>
                            <div style="height: 200px;">
                                <canvas id="entropyBoxChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Threat Vector Correlation Explorer -->
                <div class="correlation-container analytics-panel panel-large">
                    <div class="correlation-header">
                        <h2><i class="fas fa-project-diagram"></i> Threat Vector Correlation Explorer</h2>
                        <p class="correlation-subtitle">Interactive intelligence map showing relationships between malware families, agents, APIs, and indicators</p>
                    </div>
                    <div class="graph-controls">
                        <button class="graph-btn" onclick="resetGraph()"><i class="fas fa-sync"></i> Reset View</button>
                        <button class="graph-btn" onclick="centerGraph()"><i class="fas fa-compress"></i> Center</button>
                        <div class="graph-legend">
                            <span class="legend-item"><span class="node-sample malware-node"></span> Malware Family</span>
                            <span class="legend-item"><span class="node-sample agent-node"></span> Agent/System</span>
                            <span class="legend-item"><span class="node-sample api-node"></span> API Call</span>
                            <span class="legend-item"><span class="node-sample string-node"></span> Suspicious String</span>
                        </div>
                    </div>
                    <div id="correlationGraph"></div>
                    <div id="nodeDetails" class="node-details" style="display: none;">
                        <h3 id="detailsTitle"></h3>
                        <div id="detailsContent"></div>
                    </div>
                </div>

                <!-- Emerging Threat Intelligence Panel -->
                <div class="eti-container analytics-panel panel-large">
                    <div class="eti-header">
                        <h2><i class="fas fa-exclamation-triangle"></i> Emerging Threat Intelligence (ETI)</h2>
                        <p class="eti-subtitle">Real-time actionable intelligence on active threats and indicators of compromise</p>
                        <div class="eti-summary">
                            <span class="eti-badge" id="eti-total">0 Total Threats</span>
                            <span class="eti-badge recent" id="eti-recent">0 Last 24h</span>
                        </div>
                    </div>
                    
                    <div class="eti-grid">
                        <div class="eti-panel">
                            <h3><i class="fas fa-virus"></i> Top Malware Families</h3>
                            <div class="eti-subtitle-small">Most active malware families detected</div>
                            <div id="eti-malware" class="eti-list"></div>
                        </div>
                        
                        <div class="eti-panel">
                            <h3><i class="fas fa-code"></i> Top Suspicious APIs</h3>
                            <div class="eti-subtitle-small">Most frequently called malicious APIs</div>
                            <div id="eti-apis" class="eti-list"></div>
                        </div>
                        
                        <div class="eti-panel">
                            <h3><i class="fas fa-terminal"></i> Top Malicious Strings</h3>
                            <div class="eti-subtitle-small">Most common IOC strings and commands</div>
                            <div id="eti-strings" class="eti-list"></div>
                        </div>
                        
                        <div class="eti-panel">
                            <h3><i class="fas fa-shield-alt"></i> Top Packers/Obfuscators</h3>
                            <div class="eti-subtitle-small">Most used evasion techniques</div>
                            <div id="eti-packers" class="eti-list"></div>
                        </div>
                    </div>
                </div>

                <!-- Predictive Threat Modeler -->
                <div class="modeler-container analytics-panel panel-large">
                    <div class="modeler-header">
                        <h2><i class="fas fa-flask"></i> Predictive Threat Modeler</h2>
                        <p class="modeler-subtitle">Build hypothetical malware and predict how mAIware would classify it</p>
                    </div>
                    
                    <div class="modeler-grid">
                <div class="modeler-builder">
                    <h3><i class="fas fa-cogs"></i> Threat Configuration</h3>
                    
                    <div class="modeler-field">
                        <label>File Type</label>
                        <select id="model-filetype" class="modeler-select">
                            <option>PE32+ (GUI) x86-64</option>
                            <option>PE32 (Console) Intel 80386</option>
                            <option>PE32+ DLL x86-64</option>
                            <option>MSI Installer</option>
                            <option>PDF Document</option>
                        </select>
                    </div>
                    
                    <div class="modeler-field">
                        <label>Packer/Obfuscator</label>
                        <select id="model-packer" class="modeler-select">
                            <option>None</option>
                            <option>UPX</option>
                            <option>VMProtect</option>
                            <option>Themida</option>
                            <option>ASPack</option>
                            <option>Unknown (High Entropy)</option>
                        </select>
                    </div>
                    
                    <div class="modeler-field">
                        <label>Digital Signature</label>
                        <select id="model-signature" class="modeler-select">
                            <option>Verified (Microsoft Corporation)</option>
                            <option>Verified (Google LLC)</option>
                            <option>Verified (Unknown Publisher)</option>
                            <option>Not Signed</option>
                            <option>Expired Certificate</option>
                            <option>Self-Signed (Untrusted)</option>
                        </select>
                    </div>
                    
                    <div class="modeler-field">
                        <label>API Imports (select multiple)</label>
                        <select id="model-apis" class="modeler-select" multiple size="6">
                            <option>CreateRemoteThread</option>
                            <option>WriteProcessMemory</option>
                            <option>VirtualAllocEx</option>
                            <option>SetWindowsHookExW</option>
                            <option>URLDownloadToFileW</option>
                            <option>WinExec</option>
                            <option>RegSetValueExW</option>
                            <option>CryptEncrypt</option>
                            <option>Socket</option>
                            <option>ReadFile</option>
                        </select>
                        <small class="modeler-hint">Hold Ctrl/Cmd to select multiple</small>
                    </div>
                    
                    <div class="modeler-field">
                        <label>Suspicious Strings (select multiple)</label>
                        <select id="model-strings" class="modeler-select" multiple size="6">
                            <option>http://bad-c2-server.com/payload.dat</option>
                            <option>keylog.txt</option>
                            <option>steal_passwords</option>
                            <option>powershell -enc</option>
                            <option>vssadmin.exe delete shadows</option>
                            <option>HOW_TO_DECRYPT.txt</option>
                            <option>crack</option>
                            <option>patch</option>
                            <option>disable_antivirus</option>
                        </select>
                        <small class="modeler-hint">Hold Ctrl/Cmd to select multiple</small>
                    </div>
                    
                    <button class="modeler-analyze-btn" onclick="analyzeThreatModel()">
                        <i class="fas fa-brain"></i> ANALYZE THREAT
                    </button>
                </div>
                
                <div class="modeler-results">
                    <h3><i class="fas fa-chart-line"></i> Prediction Results</h3>
                    <div id="modeler-output" class="modeler-output">
                        <div class="modeler-placeholder">
                            <i class="fas fa-arrow-left"></i>
                            <p>Configure a threat profile and click ANALYZE to see predictions</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
            </div>
        </div>
    </div>
    
    <script>
        // Helper function to get CSS variable values dynamically for theming
        function getCSSVar(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        // Back to Top Button
        const backToTopBtn = document.getElementById('backToTop');
        
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopBtn.classList.add('visible');
            } else {
                backToTopBtn.classList.remove('visible');
            }
        });

        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // View Switching System
        function switchView(viewName) {
            const views = document.querySelectorAll('.view-container');
            
            views.forEach(view => {
                view.classList.remove('active');
                if (view.id === `${viewName}View`) {
                    view.classList.add('active');
                }
            });
            
            currentView = viewName;
            
            // Fix map display when switching to analytics view
            if (viewName === 'analytics') {
                loadAnalytics(); // Lazy load analytics components
                setTimeout(() => {
                    if (worldMap) {
                        worldMap.invalidateSize();
                    }
                    // Capture screenshot for preview after charts has rendered
                    setTimeout(() => {
                        createAnalyticsMiniview();
                    }, 1500);
                }, 100);
            }
            
            // Close graphs preview when switching views
            document.getElementById('graphsPreview').classList.remove('show');
            document.getElementById('previewBackdrop').classList.remove('show');
        }
        
        // Side Panel Hover System
        const sidePanel = document.getElementById('sidePanel');
        const graphsPreview = document.getElementById('graphsPreview');
        const previewBackdrop = document.getElementById('previewBackdrop');
        const homeNavBtn = document.getElementById('homeNavBtn');
        let previewTimeout;
        let previewsRendered = false;
        let currentView = 'dashboard';
        
        // Show preview panel on sidebar hover
        sidePanel.addEventListener('mouseenter', () => {
            clearTimeout(previewTimeout);
            previewTimeout = setTimeout(() => {
                graphsPreview.classList.add('show');
                previewBackdrop.classList.add('show');
                
                // Show/hide home button based on current view
                if (currentView === 'analytics') {
                    homeNavBtn.classList.add('visible');
                } else {
                    homeNavBtn.classList.remove('visible');
                }
            }, 200);
        });
        
        sidePanel.addEventListener('mouseleave', () => {
            clearTimeout(previewTimeout);
            setTimeout(() => {
                if (!graphsPreview.matches(':hover')) {
                    graphsPreview.classList.remove('show');
                    previewBackdrop.classList.remove('show');
                }
            }, 100);
        });
        
        // Keep preview open when hovering over it
        graphsPreview.addEventListener('mouseleave', () => {
            graphsPreview.classList.remove('show');
            previewBackdrop.classList.remove('show');
        });
        
        // Close preview when clicking backdrop
        previewBackdrop.addEventListener('click', () => {
            graphsPreview.classList.remove('show');
            previewBackdrop.classList.remove('show');
        });
        
        // Create analytics miniview by taking a screenshot
        let isCapturingSnapshot = false;
        let hasInitialSnapshot = false;
        
        async function createAnalyticsMiniview() {
            // Simplified - no actual screenshot, just a visual preview
            hasInitialSnapshot = true;
        }
        
        // Auto-scroll on hover down in analytics view
        let scrollInterval;
        const analyticsGrid = document.getElementById('analyticsGrid');
        
        if (analyticsGrid) {
            analyticsGrid.addEventListener('mousemove', (e) => {
                const rect = analyticsGrid.getBoundingClientRect();
                const mouseY = e.clientY - rect.top;
                const triggerZone = 100; // pixels from bottom
                
                if (rect.height - mouseY < triggerZone) {
                    if (!scrollInterval) {
                        scrollInterval = setInterval(() => {
                            analyticsGrid.scrollBy({ top: 2, behavior: 'smooth' });
                        }, 16);
                    }
                } else {
                    if (scrollInterval) {
                        clearInterval(scrollInterval);
                        scrollInterval = null;
                    }
                }
            });
            
            analyticsGrid.addEventListener('mouseleave', () => {
                if (scrollInterval) {
                    clearInterval(scrollInterval);
                    scrollInterval = null;
                }
            });
        }
        
        // Theme Toggle
        window.toggleTheme = function() {
            const html = document.documentElement;
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            
            const currentTheme = html.getAttribute('data-theme');
            
            if (currentTheme === 'light') {
                html.setAttribute('data-theme', '');
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark';
                localStorage.setItem('theme', 'dark');
            } else {
                html.setAttribute('data-theme', 'light');
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'Light';
                localStorage.setItem('theme', 'light');
            }
        };
        
        // Load saved theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'light') {
            document.documentElement.setAttribute('data-theme', 'light');
            document.getElementById('themeIcon').textContent = '‚òÄÔ∏è';
            document.getElementById('themeText').textContent = 'Light';
        }
        
        let dailyChart = null;
        let currentChartDays = 30;
        
        // Notification and Animation System
        const notificationQueue = [];
        let isShowingNotification = false;
        
        function showThreatNotification(scan) {
            const container = document.getElementById('notification-container');
            
            const classColor = 
                scan.classification === 'Malware' ? '#ff4757' :
                scan.classification === 'Suspicious' ? '#ffa502' : '#26de81';
            
            const icon = 
                scan.classification === 'Malware' ? 'fa-skull-crossbones' :
                scan.classification === 'Suspicious' ? 'fa-exclamation-triangle' : 'fa-check-circle';
            
            const notification = document.createElement('div');
            notification.className = 'threat-notification';
            notification.style.borderLeftColor = classColor;
            notification.innerHTML = `
                <div class="notification-icon" style="color: ${classColor};">
                    <i class="fas ${icon}"></i>
                </div>
                <div class="notification-content">
                    <div class="notification-title">
                        <strong>${scan.classification}</strong> detected
                    </div>
                    <div class="notification-details">
                        ${scan.detected_filename}
                        ${scan.malware_family ? ` - ${scan.malware_family}` : ''}
                    </div>
                    <div class="notification-meta">
                        <i class="fas fa-desktop"></i> ${scan.systemInfo?.hostname || scan.clientIp || 'Unknown'}
                    </div>
                </div>
                <div class="notification-close" onclick="this.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </div>
            `;
            
            container.appendChild(notification);
            
            // Animate in
            setTimeout(() => notification.classList.add('show'), 10);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 8000);
        }
        
        function addToThreatTicker(scan) {
            const ticker = document.getElementById('ticker-content');
            const timestamp = new Date(scan.serverTimestamp).toLocaleTimeString();
            
            const classColor = 
                scan.classification === 'Malware' ? '#ff4757' :
                scan.classification === 'Suspicious' ? '#ffa502' : '#26de81';
            
            const tickerItem = document.createElement('span');
            tickerItem.className = 'ticker-item';
            tickerItem.style.color = classColor;
            tickerItem.innerHTML = `
                <i class="fas fa-circle"></i>
                [${timestamp}] ${scan.classification}: ${scan.detected_filename}
                ${scan.malware_family ? `(${scan.malware_family})` : ''}
                on ${scan.systemInfo?.hostname || scan.clientIp || 'Unknown'}
            `;
            
            ticker.appendChild(tickerItem);
            
            // Keep only last 10 items
            while (ticker.children.length > 10) {
                ticker.removeChild(ticker.firstChild);
            }
        }
        
        function animateStatCard(elementId, newValue) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            const currentValue = parseInt(element.textContent) || 0;
            if (newValue > currentValue) {
                // Pulse animation
                element.parentElement.classList.add('stat-pulse');
                setTimeout(() => element.parentElement.classList.remove('stat-pulse'), 600);
                
                // Animate number increment
                const duration = 500;
                const steps = 20;
                const increment = (newValue - currentValue) / steps;
                let current = currentValue;
                let step = 0;
                
                const interval = setInterval(() => {
                    step++;
                    current += increment;
                    element.textContent = Math.round(current);
                    
                    if (step >= steps) {
                        element.textContent = newValue;
                        clearInterval(interval);
                    }
                }, duration / steps);
            } else {
                element.textContent = newValue;
            }
        }

        function renderStats(stats) {
            if (!stats) return;

            animateStatCard('stat-clients', stats.activeClients);
            animateStatCard('stat-total', stats.totalScans);
            animateStatCard('stat-malware', stats.malwareCount);
            animateStatCard('stat-suspicious', stats.suspiciousCount);
            animateStatCard('stat-benign', stats.benignCount);
            animateStatCard('stat-site-visits', stats.siteVisits || stats.totalScans);
        }
        
        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                const stats = await response.json();
                renderStats(stats);
            } catch (error) {
                console.error('Failed to load stats:', error);
            }
        }
        
        async function loadScans() {
            try {
                const response = await fetch('/api/scans?limit=50');
                const data = await response.json();
                
                const tbody = document.getElementById('scans-tbody');
                
                if (data.scans.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="5" class="empty-state">
                                <i class="fas fa-inbox"></i>
                                <p>No scans yet. Waiting for clients...</p>
                            </td>
                        </tr>
                    `;
                    return;
                }
                
                tbody.innerHTML = data.scans.map(scan => {
                    const timestamp = new Date(scan.serverTimestamp).toLocaleString();
                    const hash = scan.file_hashes?.sha256 || 'N/A';
                    const hashShort = hash.length > 16 ? (hash.substring(0, 16) + '...') : hash;
                    const isNonPe = scan.is_pe === false;
                    const classification = isNonPe ? 'Non-PE' : (scan.classification || 'Unknown');
                    const badgeClass = isNonPe ? 'non-pe' : classification.toLowerCase();
                    const nonPeTag = isNonPe ? '<span class="badge non-pe" title="Non-PE file">Non-PE</span>' : '';
                    return `
                        <tr>
                            <td>${timestamp}</td>
                            <td>${scan.detected_filename} ${nonPeTag}</td>
                            <td><span class="badge ${badgeClass}">${classification}</span></td>
                            <td>${scan.systemInfo?.ip || scan.clientIp || 'Unknown'}</td>
                            <td class="hash" title="${hash}">${hashShort}</td>
                        </tr>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Failed to load scans:', error);
            }
        }
        
        async function loadDailyChart() {
            try {
                const response = await fetch(`/api/daily-scans?days=${currentChartDays}`);
                const data = await response.json();
                
                const ctx = document.getElementById('dailyScansChart');
                
                // Format dates for display (MM/DD)
                const labels = data.days.map(day => {
                    const date = new Date(day.date);
                    return `${date.getMonth() + 1}/${date.getDate()}`;
                });
                
                // Reuse existing chart if it exists
                if (dailyChart) {
                    dailyChart.data.labels = labels;
                    dailyChart.data.datasets[0].data = data.days.map(d => d.total);
                    dailyChart.data.datasets[1].data = data.days.map(d => d.malware);
                    dailyChart.data.datasets[2].data = data.days.map(d => d.suspicious);
                    dailyChart.data.datasets[3].data = data.days.map(d => d.benign);
                    dailyChart.update('none'); // Update without animation
                    return;
                }
                
                dailyChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Total Scans',
                                data: data.days.map(d => d.total),
                                borderColor: '#5a9cf8',
                                backgroundColor: 'rgba(90, 156, 248, 0.1)',
                                fill: true,
                                tension: 0.4,
                                borderWidth: 2
                            },
                            {
                                label: 'Malware',
                                data: data.days.map(d => d.malware),
                                borderColor: '#ff4757',
                                backgroundColor: 'rgba(255, 71, 87, 0.1)',
                                fill: true,
                                tension: 0.4,
                                borderWidth: 2
                            },
                            {
                                label: 'Suspicious',
                                data: data.days.map(d => d.suspicious),
                                borderColor: '#ffa502',
                                backgroundColor: 'rgba(255, 165, 2, 0.1)',
                                fill: true,
                                tension: 0.4,
                                borderWidth: 2
                            },
                            {
                                label: 'Benign',
                                data: data.days.map(d => d.benign),
                                borderColor: '#34d118',
                                backgroundColor: 'rgba(52, 209, 24, 0.1)',
                                fill: true,
                                tension: 0.4,
                                borderWidth: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: getCSSVar('--chart-text-color') || '#e0e0e0',
                                    font: { size: 12 }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#fff',
                                bodyColor: '#e0e0e0',
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                ticks: { 
                                    color: getCSSVar('--chart-text-color') || '#888',
                                    maxRotation: 45,
                                    minRotation: 45
                                },
                                grid: { 
                                    color: getCSSVar('--chart-grid-color') || 'rgba(255, 255, 255, 0.05)' 
                                }
                            },
                            y: {
                                beginAtZero: true,
                                ticks: { 
                                    color: getCSSVar('--chart-text-color') || '#888',
                                    stepSize: 1
                                },
                                grid: { 
                                    color: getCSSVar('--chart-grid-color') || 'rgba(255, 255, 255, 0.05)' 
                                }
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Failed to load daily chart:', error);
            }
        }
        
        let worldMap = null;
        let markerLayer = null;
        let heatmapLayer = null;
        let choroplethLayer = null;
        let mapInitialized = false;
        let lastGeoDataHash = '';
        let sourceChart = null;
        let currentMapView = 'markers';
        let geoDataCache = null;
        let replayInterval = null;
        
        // Country boundaries for choropleth (simplified)
        const countryCoordinates = {
            'United States': { center: [37.0902, -95.7129], weight: 0 },
            'China': { center: [35.8617, 104.1954], weight: 0 },
            'United Kingdom': { center: [55.3781, -3.4360], weight: 0 },
            'Germany': { center: [51.1657, 10.4515], weight: 0 },
            'France': { center: [46.2276, 2.2137], weight: 0 },
            'Russia': { center: [61.5240, 105.3188], weight: 0 },
            'Japan': { center: [36.2048, 138.2529], weight: 0 },
            'India': { center: [20.5937, 78.9629], weight: 0 },
            'Brazil': { center: [-14.2350, -51.9253], weight: 0 },
            'Australia': { center: [-25.2744, 133.7751], weight: 0 }
        };
        
        function initializeMap() {
            if (mapInitialized) return;
            
            try {
                worldMap = L.map('worldMap', {
                    zoomControl: true,
                    scrollWheelZoom: true,
                    preferCanvas: false,
                    worldCopyJump: true
                }).setView([20, 0], 2);
                
                // Use dark theme tiles
                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    attribution: '&copy; OpenStreetMap contributors',
                    subdomains: 'abcd',
                    maxZoom: 18,
                    minZoom: 1,
                    noWrap: false,
                    bounds: [[-90, -180], [90, 180]]
                }).addTo(worldMap);
                
                markerLayer = L.layerGroup().addTo(worldMap);
                mapInitialized = true;
                
                // Fix map display after initialization
                setTimeout(() => {
                    if (worldMap) worldMap.invalidateSize();
                }, 100);
            } catch (error) {
                console.error('Failed to initialize map:', error);
            }
        }
        
        // Switch between map visualization modes
        window.switchMapView = function(view) {
            currentMapView = view;
            
            // Update button states
            document.querySelectorAll('.map-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            
            // Reload map with new view
            if (geoDataCache) {
                renderMapView(geoDataCache);
            }
        };
        
        // Render different map views
        function renderMapView(data) {
            if (!worldMap) return;
            
            // Clear all layers
            if (markerLayer) markerLayer.clearLayers();
            if (heatmapLayer) {
                worldMap.removeLayer(heatmapLayer);
                heatmapLayer = null;
            }
            if (choroplethLayer) {
                worldMap.removeLayer(choroplethLayer);
                choroplethLayer = null;
            }
            
            switch (currentMapView) {
                case 'markers':
                    renderMarkers(data);
                    break;
                case 'heatmap':
                    renderHeatmap(data);
                    break;
                case 'choropleth':
                    renderChoropleth(data);
                    break;
            }
            
            updateGeoContext(data);
        }
        
        // Render traditional markers
        function renderMarkers(data) {
            data.locations.forEach(location => {
                const { lat, lng, city, country } = location.location;
                
                let markerColor = '#26de81'; // benign
                if (location.malwareCount > 0) {
                    markerColor = '#ff3b3b'; // malware
                } else if (location.suspiciousCount > 0) {
                    markerColor = '#ffd700'; // suspicious
                }
                
                const markerSize = Math.min(24, Math.max(8, 8 + location.totalScans * 2));
                
                const marker = L.circleMarker([lat, lng], {
                    radius: markerSize / 2,
                    fillColor: markerColor,
                    color: '#fff',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.6
                });
                
                const popupContent = `
                    <div style="color: var(--text-primary); min-width: 200px;">
                        <h3 style="margin: 0 0 10px 0; color: var(--accent-green); font-size: 1.1rem;">
                            <i class="fas fa-map-marker-alt" style="color: ${markerColor};"></i>
                            ${city}, ${country}
                        </h3>
                        <p style="margin: 5px 0;"><strong>IP:</strong> ${location.ip}</p>
                        <p style="margin: 5px 0;"><strong>Total Scans:</strong> ${location.totalScans}</p>
                        <div style="margin-top: 10px;">
                            <div><span style="color: #ff3b3b;">‚óè</span> Malware: ${location.malwareCount}</div>
                            <div><span style="color: #ffd700;">‚óè</span> Suspicious: ${location.suspiciousCount}</div>
                            <div><span style="color: #34d118;">‚óè</span> Benign: ${location.benignCount}</div>
                        </div>
                        <button onclick="filterByLocation('${country}')" 
                                style="margin-top: 10px; padding: 5px 10px; background: var(--accent-green); 
                                       color: var(--bg-primary); border: none; border-radius: 5px; cursor: pointer;">
                            Filter by ${country}
                        </button>
                    </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(markerLayer);
                
                marker.on('mouseover', function() {
                    this.setStyle({ fillOpacity: 0.9, opacity: 1 });
                });
                marker.on('mouseout', function() {
                    this.setStyle({ fillOpacity: 0.6, opacity: 0.8 });
                });
            });
        }
        
        // Render heatmap overlay
        function renderHeatmap(data) {
            const heatData = [];
            
            data.locations.forEach(location => {
                const { lat, lng } = location.location;
                // Weight by threat severity: malware = 1.0, suspicious = 0.5, benign = 0.2
                const weight = (location.malwareCount * 1.0 + 
                               location.suspiciousCount * 0.5 + 
                               location.benignCount * 0.2) / location.totalScans;
                
                // Add multiple points for higher intensity
                const intensity = Math.ceil(location.totalScans * weight);
                for (let i = 0; i < intensity; i++) {
                    heatData.push([lat, lng, weight]);
                }
            });
            
            heatmapLayer = L.heatLayer(heatData, {
                radius: 35,
                blur: 25,
                maxZoom: 10,
                max: 1.0,
                gradient: {
                    0.0: '#34d118',  // Green (low threat)
                    0.3: '#ffd700',  // Yellow
                    0.6: '#ffa502',  // Orange
                    0.8: '#ff6348',  // Red
                    1.0: '#ff3b3b'   // Bright red (high threat)
                }
            }).addTo(worldMap);
        }
        
        // Render choropleth (country-level threat shading)
        function renderChoropleth(data) {
            // Aggregate threats by country
            const countryStats = {};
            data.locations.forEach(location => {
                const country = location.location.country;
                if (!countryStats[country]) {
                    countryStats[country] = { total: 0, malware: 0, suspicious: 0 };
                }
                countryStats[country].total += location.totalScans;
                countryStats[country].malware += location.malwareCount;
                countryStats[country].suspicious += location.suspiciousCount;
            });
            
            // Find max for normalization
            const maxThreats = Math.max(...Object.values(countryStats).map(s => 
                s.malware + s.suspicious * 0.5
            ));
            
            // Draw circles for countries with threat data
            choroplethLayer = L.layerGroup();
            
            Object.entries(countryStats).forEach(([country, stats]) => {
                if (countryCoordinates[country]) {
                    const threatScore = (stats.malware + stats.suspicious * 0.5) / maxThreats;
                    
                    // Color gradient from green to red
                    let color;
                    if (threatScore < 0.2) color = '#34d118';
                    else if (threatScore < 0.4) color = '#ffd700';
                    else if (threatScore < 0.6) color = '#ffa502';
                    else if (threatScore < 0.8) color = '#ff6348';
                    else color = '#ff3b3b';
                    
                    const circle = L.circle(countryCoordinates[country].center, {
                        color: color,
                        fillColor: color,
                        fillOpacity: 0.4,
                        radius: 500000 * (1 + threatScore * 2),
                        weight: 2
                    });
                    
                    circle.bindPopup(`
                        <div style="color: var(--text-primary);">
                            <h3 style="color: var(--accent-green);">${country}</h3>
                            <p><strong>Total Threats:</strong> ${stats.total}</p>
                            <p><strong>Malware:</strong> ${stats.malware}</p>
                            <p><strong>Suspicious:</strong> ${stats.suspicious}</p>
                            <p><strong>Threat Level:</strong> ${(threatScore * 100).toFixed(0)}%</p>
                        </div>
                    `);
                    
                    circle.addTo(choroplethLayer);
                }
            });
            
            choroplethLayer.addTo(worldMap);
        }
        
        // Update geographic context panel
        function updateGeoContext(data) {
            const countries = new Set(data.locations.map(l => l.location.country));
            document.getElementById('activeRegions').textContent = countries.size;
            
            // Find hotspot (country with most threats)
            const countryThreats = {};
            data.locations.forEach(loc => {
                const country = loc.location.country;
                countryThreats[country] = (countryThreats[country] || 0) + 
                    loc.malwareCount + loc.suspiciousCount;
            });
            
            const hotspot = Object.entries(countryThreats)
                .sort((a, b) => b[1] - a[1])[0];
            
            if (hotspot) {
                const percentage = ((hotspot[1] / data.locations.reduce((sum, l) => 
                    sum + l.malwareCount + l.suspiciousCount, 0)) * 100).toFixed(0);
                document.getElementById('topRegion').textContent = 
                    `${hotspot[0]} (${percentage}% of threats)`;
            }
            
            const totalThreats = data.locations.reduce((sum, l) => 
                sum + l.malwareCount + l.suspiciousCount, 0);
            document.getElementById('geoThreatCount').textContent = totalThreats;
        }
        
        // Filter dashboard by geographic location
        window.filterByLocation = function(country) {
            console.log(`Filtering by country: ${country}`);
            // This would filter the tables and charts - simplified for demo
            alert(`Geographic filtering activated for ${country}.\nIn full implementation, this would filter all dashboard data.`);
        };
        
        // Replay threats over last 24 hours
        window.replayThreats = async function() {
            const btn = document.getElementById('replayBtn');
            const info = document.getElementById('timelineInfo');
            
            if (replayInterval) {
                clearInterval(replayInterval);
                replayInterval = null;
                btn.innerHTML = '<i class="fas fa-play"></i> Replay Last 24h';
                info.textContent = 'Replay stopped';
                if (geoDataCache) renderMapView(geoDataCache);
                return;
            }
            
            if (!geoDataCache || geoDataCache.locations.length === 0) {
                info.textContent = 'No data available for replay';
                return;
            }
            
            btn.innerHTML = '<i class="fas fa-stop"></i> Stop Replay';
            info.textContent = 'Replaying threat detection timeline...';
            
            // Sort locations by timestamp
            const sortedLocations = [...geoDataCache.locations].sort((a, b) => {
                const timeA = a.scans[0]?.timestamp || 0;
                const timeB = b.scans[0]?.timestamp || 0;
                return new Date(timeA) - new Date(timeB);
            });
            
            if (markerLayer) markerLayer.clearLayers();
            let index = 0;
            
            replayInterval = setInterval(() => {
                if (index >= sortedLocations.length) {
                    clearInterval(replayInterval);
                    replayInterval = null;
                    btn.innerHTML = '<i class="fas fa-play"></i> Replay Last 24h';
                    info.textContent = 'Replay complete';
                    return;
                }
                
                const location = sortedLocations[index];
                const { lat, lng, city, country } = location.location;
                
                let markerColor = location.malwareCount > 0 ? '#ff3b3b' : 
                                 location.suspiciousCount > 0 ? '#ffd700' : '#34d118';
                
                // Animated marker appearance
                const marker = L.circleMarker([lat, lng], {
                    radius: 0,
                    fillColor: markerColor,
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(markerLayer);
                
                // Animate marker growth
                let size = 0;
                const growInterval = setInterval(() => {
                    size += 2;
                    if (size >= 12) {
                        clearInterval(growInterval);
                        marker.setStyle({ opacity: 0.8, fillOpacity: 0.6 });
                    }
                    marker.setRadius(size / 2);
                }, 50);
                
                marker.bindPopup(`
                    <div style="color: var(--text-primary);">
                        <strong>${city}, ${country}</strong><br>
                        ${location.scans[0]?.filename || 'Unknown file'}
                    </div>
                `);
                
                info.textContent = `Replaying: ${index + 1}/${sortedLocations.length} - ${city}, ${country}`;
                index++;
            }, 800); // Show new threat every 800ms
        };
        
        async function loadGeoMap() {
            try {
                // Initialize map only once
                if (!mapInitialized) {
                    initializeMap();
                }
                
                if (!worldMap) return;
                
                const response = await fetch('/api/geo-data');
                const data = await response.json();
                
                // Generate hash of current data to detect changes
                const currentHash = JSON.stringify(data.locations.map(l => 
                    `${l.ip}-${l.totalScans}-${l.malwareCount}-${l.suspiciousCount}`
                )).substring(0, 100);
                
                // Skip update if data hasn't changed
                if (currentHash === lastGeoDataHash && markerLayer && markerLayer.getLayers().length > 0) {
                    return;
                }
                lastGeoDataHash = currentHash;
                
                // Cache data for replay and other features
                geoDataCache = data;
                
                // Render current view
                renderMapView(data);
                
                console.log(`Map updated with ${data.locations.length} locations in ${currentMapView} mode`);
                
            } catch (error) {
                console.error('Failed to load geo map:', error);
            }
        }
        
        async function loadMalwareSources() {
            try {
                const response = await fetch('/api/malware-sources');
                const data = await response.json();
                
                const ctx = document.getElementById('malwareSourceChart');
                
                const labels = data.sources.map(s => s.source);
                const counts = data.sources.map(s => s.count);
                
                // Color scheme for different sources
                const colors = [
                    '#ff6b6b', // Email Attachment - red
                    '#4ecdc4', // Web Download - teal
                    '#ffe66d', // USB/External Drive - yellow
                    '#a8dadc', // Internal Network - light blue
                    '#95a5a6'  // Unknown - gray
                ];
                
                // Reuse existing chart if it exists
                if (sourceChart) {
                    sourceChart.data.labels = labels;
                    sourceChart.data.datasets[0].data = counts;
                    sourceChart.update('none');
                    return;
                }
                
                sourceChart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: counts,
                            backgroundColor: colors,
                            borderColor: '#1a1a2e',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: getCSSVar('--chart-text-color') || '#e0e0e0',
                                    font: { size: 12 },
                                    padding: 15
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#fff',
                                bodyColor: '#e0e0e0',
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 1,
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Failed to load malware sources:', error);
            }
        }
        
        // Graph 2: "Noisiest" Agents Over Time
        let noisyAgentsChart = null;
        async function loadNoisyAgentsChart() {
            try {
                const response = await fetch('/api/noisy-agents');
                const data = await response.json();
                
                console.log('Noisy agents data:', data);
                
                const ctx = document.getElementById('noisyAgentsChart');
                if (!ctx) return;
                
                // Show message if no data
                if (!data.agents || data.agents.length === 0) {
                    ctx.parentElement.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary);">No agent data available yet. Start scanning files to see trends.</div>';
                    return;
                }
                
                const colors = [
                    '#ff3b3b', '#34d118', '#ffd700', '#1e90ff', '#ff1493'
                ];
                
                // Reuse existing chart if it exists
                if (noisyAgentsChart) {
                    noisyAgentsChart.data.labels = data.dates;
                    noisyAgentsChart.data.datasets = data.agents.map((agent, idx) => ({
                        label: agent.agentId,
                        data: agent.counts,
                        borderColor: colors[idx],
                        backgroundColor: colors[idx] + '20',
                        tension: 0.4,
                        borderWidth: 2,
                        fill: false
                    }));
                    noisyAgentsChart.update('none');
                    return;
                }
                
                noisyAgentsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.dates,
                        datasets: data.agents.map((agent, idx) => ({
                            label: agent.agentId,
                            data: agent.counts,
                            borderColor: colors[idx],
                            backgroundColor: colors[idx] + '20',
                            tension: 0.4,
                            borderWidth: 2,
                            fill: false
                        }))
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: getCSSVar('--chart-text-color') || '#e0e0e0',
                                    font: { size: 11 }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#fff',
                                bodyColor: '#e0e0e0'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: getCSSVar('--chart-text-color') || '#888' },
                                grid: { color: getCSSVar('--chart-grid-color') || 'rgba(255, 255, 255, 0.05)' }
                            },
                            x: {
                                ticks: { color: getCSSVar('--chart-text-color') || '#888' },
                                grid: { color: getCSSVar('--chart-grid-color') || 'rgba(255, 255, 255, 0.05)' }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to load noisy agents chart:', error);
                const ctx = document.getElementById('noisyAgentsChart');
                if (ctx) {
                    ctx.parentElement.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--accent-red);">Error loading chart data</div>';
                }
            }
        }
        
        // Graph 3: Signature Status vs. Classification
        let signatureClassChart = null;
        async function loadSignatureClassChart() {
            try {
                const response = await fetch('/api/signature-classification');
                const data = await response.json();
                
                console.log('Signature classification data:', data);
                
                const ctx = document.getElementById('signatureClassChart');
                if (!ctx) {
                    console.warn('signatureClassChart canvas not found');
                    return;
                }
                
                // Reuse existing chart if it exists
                if (signatureClassChart) {
                    signatureClassChart.data.datasets[0].data = [data.benign.verified, data.suspicious.verified, data.malware.verified];
                    signatureClassChart.data.datasets[1].data = [data.benign.unknown, data.suspicious.unknown, data.malware.unknown];
                    signatureClassChart.data.datasets[2].data = [data.benign.untrusted, data.suspicious.untrusted, data.malware.untrusted];
                    signatureClassChart.update('none');
                    return;
                }
                
                signatureClassChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Benign', 'Suspicious', 'Malware'],
                        datasets: [
                            {
                                label: 'Verified',
                                data: [data.benign.verified, data.suspicious.verified, data.malware.verified],
                                backgroundColor: '#34d118',
                                stack: 'stack0'
                            },
                            {
                                label: 'Unknown',
                                data: [data.benign.unknown, data.suspicious.unknown, data.malware.unknown],
                                backgroundColor: '#ffd700',
                                stack: 'stack0'
                            },
                            {
                                label: 'Untrusted',
                                data: [data.benign.untrusted, data.suspicious.untrusted, data.malware.untrusted],
                                backgroundColor: '#ff3b3b',
                                stack: 'stack0'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#e0e0e0', font: { size: 11 } }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                callbacks: {
                                    label: function(context) {
                                        const total = context.chart.data.datasets
                                            .reduce((sum, ds) => sum + ds.data[context.dataIndex], 0);
                                        const percentage = ((context.parsed.y / total) * 100).toFixed(1);
                                        return `${context.dataset.label}: ${context.parsed.y} (${percentage}%)`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                stacked: true,
                                ticks: { color: '#888' },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' }
                            },
                            x: {
                                stacked: true,
                                ticks: { color: '#888' },
                                grid: { display: false }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to load signature classification chart:', error);
                const ctx = document.getElementById('signatureClassChart');
                if (ctx && ctx.parentElement) {
                    ctx.parentElement.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-secondary); font-size: 0.85rem;">No data available</div>';
                }
            }
        }
        
        // Graph 4: Packer Usage vs. Classification
        let packerClassChart = null;
        async function loadPackerClassChart() {
            try {
                const response = await fetch('/api/packer-classification');
                const data = await response.json();
                
                console.log('Packer classification data:', data);
                
                const ctx = document.getElementById('packerClassChart');
                if (!ctx) {
                    console.warn('packerClassChart canvas not found');
                    return;
                }
                
                // Reuse existing chart if it exists
                if (packerClassChart) {
                    packerClassChart.data.labels = data.packers;
                    packerClassChart.data.datasets[0].data = data.benignCounts;
                    packerClassChart.data.datasets[1].data = data.malwareCounts;
                    packerClassChart.update('none');
                    return;
                }
                
                packerClassChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.packers,
                        datasets: [
                            {
                                label: 'Benign Files',
                                data: data.benignCounts,
                                backgroundColor: '#34d118'
                            },
                            {
                                label: 'Malware Files',
                                data: data.malwareCounts,
                                backgroundColor: '#ff3b3b'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#e0e0e0', font: { size: 11 } }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#888' },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' }
                            },
                            x: {
                                ticks: { color: '#888' },
                                grid: { display: false }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to load packer classification chart:', error);
                const ctx = document.getElementById('packerClassChart');
                if (ctx && ctx.parentElement) {
                    ctx.parentElement.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-secondary); font-size: 0.85rem;">No data available</div>';
                }
            }
        }
        
        // Graph 5: Confidence Score Histogram
        let confidenceHistChart = null;
        async function loadConfidenceHistChart() {
            try {
                const response = await fetch('/api/confidence-distribution');
                const data = await response.json();
                
                console.log('Confidence distribution data:', data);
                
                const ctx = document.getElementById('confidenceHistChart');
                if (!ctx) {
                    console.warn('confidenceHistChart canvas not found');
                    return;
                }
                
                // Reuse existing chart if it exists
                if (confidenceHistChart) {
                    confidenceHistChart.data.labels = data.bins;
                    confidenceHistChart.data.datasets[0].data = data.counts;
                    confidenceHistChart.update('none');
                    return;
                }
                
                confidenceHistChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.bins,
                        datasets: [{
                            label: 'Scan Count',
                            data: data.counts,
                            backgroundColor: '#5a9cf8',
                            borderColor: '#4a8ce8',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#e0e0e0', font: { size: 11 } }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#888' },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                title: {
                                    display: true,
                                    text: 'Number of Scans',
                                    color: '#888'
                                }
                            },
                            x: {
                                ticks: { color: '#888' },
                                grid: { display: false },
                                title: {
                                    display: true,
                                    text: 'Confidence Score Range',
                                    color: '#888'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to load confidence histogram:', error);
                const ctx = document.getElementById('confidenceHistChart');
                if (ctx && ctx.parentElement) {
                    ctx.parentElement.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-secondary); font-size: 0.85rem;">No data available</div>';
                }
            }
        }
        
        // Graph 6: File Entropy Distribution (Box Plot simulation)
        let entropyBoxChart = null;
        async function loadEntropyBoxChart() {
            try {
                const response = await fetch('/api/entropy-distribution');
                const data = await response.json();
                
                console.log('Entropy distribution data:', data);
                
                const ctx = document.getElementById('entropyBoxChart');
                if (!ctx) {
                    console.warn('entropyBoxChart canvas not found');
                    return;
                }
                
                // Create violin/box plot effect with multiple bars
                const benignData = [
                    data.benign.min,
                    data.benign.q1,
                    data.benign.median,
                    data.benign.q3,
                    data.benign.max
                ];
                
                const malwareData = [
                    data.malware.min,
                    data.malware.q1,
                    data.malware.median,
                    data.malware.q3,
                    data.malware.max
                ];
                
                // Reuse existing chart if it exists
                if (entropyBoxChart) {
                    entropyBoxChart.data.datasets[0].data = benignData;
                    entropyBoxChart.data.datasets[1].data = malwareData;
                    entropyBoxChart.update('none');
                    return;
                }
                
                entropyBoxChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Min', 'Q1', 'Median', 'Q3', 'Max'],
                        datasets: [
                            {
                                label: 'Benign Files',
                                data: benignData,
                                backgroundColor: '#34d118',
                                borderColor: '#2ed60f',
                                borderWidth: 1
                            },
                            {
                                label: 'Malware Files',
                                data: malwareData,
                                backgroundColor: '#ff3b3b',
                                borderColor: '#cc2f2f',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#e0e0e0', font: { size: 11 } }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(3)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 8.0,
                                ticks: { color: '#888' },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                title: {
                                    display: true,
                                    text: 'Entropy Value',
                                    color: '#888'
                                }
                            },
                            x: {
                                ticks: { color: '#888' },
                                grid: { display: false }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to load entropy distribution chart:', error);
                const ctx = document.getElementById('entropyBoxChart');
                if (ctx && ctx.parentElement) {
                    ctx.parentElement.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-secondary); font-size: 0.85rem;">No data available</div>';
                }
            }
        }
        
        async function loadEmergingThreats() {
            try {
                const response = await fetch('/api/emerging-threats');
                const data = await response.json();
                
                // Update summary badges
                document.getElementById('eti-total').textContent = 
                    `${data.summary.totalThreats} Total Threats`;
                document.getElementById('eti-recent').textContent = 
                    `${data.summary.recentThreats} Last 24h`;
                
                // Helper to render IOC list
                const renderIOCList = (items, container) => {
                    if (items.length === 0) {
                        container.innerHTML = '<div class="eti-empty">No threats detected</div>';
                        return;
                    }
                    
                    container.innerHTML = items.map((item, index) => {
                        const rank = index + 1;
                        const recentBadge = item.recent > 0 ? 
                            `<span class="eti-recent-badge">${item.recent} recent</span>` : '';
                        const agentBadge = item.agents > 0 ? 
                            `<span class="eti-agent-badge">${item.agents} agents</span>` : '';
                        
                        return `
                            <div class="eti-item" data-rank="${rank}">
                                <div class="eti-rank">${rank}</div>
                                <div class="eti-content">
                                    <div class="eti-name">${item.name}</div>
                                    <div class="eti-meta">
                                        <span class="eti-count">${item.count} occurrences</span>
                                        ${recentBadge}
                                        ${agentBadge}
                                    </div>
                                    ${item.details && item.details.length > 0 ? `
                                        <div class="eti-details">
                                            ${item.details.slice(0, 2).join(', ')}
                                            ${item.details.length > 2 ? '...' : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    }).join('');
                };
                
                // Render each section
                renderIOCList(data.topMalwareFamilies, document.getElementById('eti-malware'));
                renderIOCList(data.topSuspiciousAPIs, document.getElementById('eti-apis'));
                renderIOCList(data.topMaliciousStrings, document.getElementById('eti-strings'));
                renderIOCList(data.topPackers, document.getElementById('eti-packers'));
                
            } catch (error) {
                console.error('Failed to load emerging threats:', error);
            }
        }
        
        async function analyzeThreatModel() {
            try {
                // Get selected values
                const fileType = document.getElementById('model-filetype').value;
                const packer = document.getElementById('model-packer').value;
                const signature = document.getElementById('model-signature').value;
                
                // Get multiple selections
                const apisSelect = document.getElementById('model-apis');
                const apiImports = Array.from(apisSelect.selectedOptions).map(opt => opt.value);
                
                const stringsSelect = document.getElementById('model-strings');
                const keyStrings = Array.from(stringsSelect.selectedOptions).map(opt => opt.value);
                
                // Validate
                if (apiImports.length === 0) {
                    alert('Please select at least one API import');
                    return;
                }
                if (keyStrings.length === 0) {
                    alert('Please select at least one suspicious string');
                    return;
                }
                
                // Show loading state
                const outputDiv = document.getElementById('modeler-output');
                outputDiv.innerHTML = `
                    <div class="modeler-loading">
                        <i class="fas fa-spinner fa-spin"></i>
                        <p>Analyzing threat profile...</p>
                    </div>
                `;
                
                // Send to server
                const response = await fetch('/api/threat-model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileType,
                        packer,
                        signature,
                        apiImports,
                        keyStrings
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const result = data.result;
                    const classColor = 
                        result.classification === 'Malware' ? '#ff4757' :
                        result.classification === 'Suspicious' ? '#ffa502' : '#26de81';
                    
                    outputDiv.innerHTML = `
                        <div class="prediction-result">
                            <div class="prediction-header">
                                <div class="prediction-badge" style="background: ${classColor};">
                                    ${result.classification.toUpperCase()}
                                </div>
                                <div class="prediction-confidence">
                                    <div class="confidence-label">Confidence Score</div>
                                    <div class="confidence-value">${(parseFloat(result.confidence_score) * 100).toFixed(1)}%</div>
                                </div>
                            </div>
                            
                            ${result.malware_family ? `
                                <div class="prediction-family">
                                    <strong>Predicted Malware Family:</strong>
                                    <span class="family-name">${result.malware_family}</span>
                                </div>
                            ` : ''}
                            
                            <div class="prediction-section">
                                <h4>Threat Analysis</h4>
                                <div class="analysis-item">
                                    <i class="fas fa-file"></i>
                                    <span><strong>File Type:</strong> ${result.key_findings.file_type}</span>
                                </div>
                                <div class="analysis-item">
                                    <i class="fas fa-box"></i>
                                    <span><strong>Packer:</strong> ${result.key_findings.packer_detected}</span>
                                </div>
                                <div class="analysis-item">
                                    <i class="fas fa-certificate"></i>
                                    <span><strong>Signature:</strong> ${result.key_findings.signature.name}</span>
                                </div>
                                <div class="analysis-item">
                                    <i class="fas fa-tachometer-alt"></i>
                                    <span><strong>Threat Score:</strong> ${result.key_findings.threat_score}/100</span>
                                </div>
                            </div>
                            
                            <div class="prediction-section">
                                <h4>Detected Indicators</h4>
                                <div class="indicator-group">
                                    <strong>API Imports:</strong>
                                    <div class="indicator-list">
                                        ${result.key_findings.api_imports.map(api => 
                                            `<span class="indicator-tag api-tag">${api}</span>`
                                        ).join('')}
                                    </div>
                                </div>
                                <div class="indicator-group">
                                    <strong>Suspicious Strings:</strong>
                                    <div class="indicator-list">
                                        ${result.key_findings.key_strings.map(str => 
                                            `<span class="indicator-tag string-tag">${str}</span>`
                                        ).join('')}
                                    </div>
                                </div>
                            </div>
                            
                            <div class="prediction-footer">
                                <i class="fas fa-info-circle"></i>
                                This analysis has been added to the scan results and will appear in all visualizations.
                            </div>
                        </div>
                    `;
                } else {
                    outputDiv.innerHTML = `
                        <div class="modeler-error">
                            <i class="fas fa-exclamation-circle"></i>
                            <p>Analysis failed: ${data.error}</p>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Failed to analyze threat model:', error);
                document.getElementById('modeler-output').innerHTML = `
                    <div class="modeler-error">
                        <i class="fas fa-exclamation-circle"></i>
                        <p>Analysis failed. Please try again.</p>
                    </div>
                `;
            }
        }
        
        let graphSimulation = null;
        let graphSvg = null;
        
        async function loadCorrelationGraph() {
            try {
                const response = await fetch('/api/threat-correlations');
                const data = await response.json();
                
                // Clear existing graph
                d3.select('#correlationGraph').selectAll('*').remove();
                
                const container = document.getElementById('correlationGraph');
                const width = container.clientWidth;
                const height = 600;
                
                // Create SVG
                graphSvg = d3.select('#correlationGraph')
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', '#0a0a0a')
                    .style('border-radius', '8px');
                
                const g = graphSvg.append('g');
                
                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                graphSvg.call(zoom);
                
                // Color schemes for different node types
                const colorMap = {
                    malware: '#ff4757',
                    agent: '#5a9cf8',
                    api: '#ffa502',
                    string: '#26de81'
                };
                
                // Create force simulation
                graphSimulation = d3.forceSimulation(data.nodes)
                    .force('link', d3.forceLink(data.links)
                        .id(d => d.id)
                        .distance(d => d.type === 'correlated_with' ? 200 : 100)
                        .strength(d => d.strength * 0.3))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(30));
                
                // Draw links
                const link = g.append('g')
                    .selectAll('line')
                    .data(data.links)
                    .enter()
                    .append('line')
                    .attr('stroke', d => {
                        if (d.type === 'correlated_with') return '#ff6b6b';
                        if (d.type === 'detected_by') return '#5a9cf8';
                        if (d.type === 'uses_api') return '#ffa502';
                        return '#26de81';
                    })
                    .attr('stroke-width', d => Math.sqrt(d.strength) + 1)
                    .attr('stroke-opacity', 0.6);
                
                // Draw nodes
                const node = g.append('g')
                    .selectAll('circle')
                    .data(data.nodes)
                    .enter()
                    .append('circle')
                    .attr('r', d => {
                        if (d.type === 'malware') return 15 + Math.min(d.count * 2, 15);
                        if (d.type === 'agent') return 12 + Math.min(d.count, 10);
                        return 8 + Math.min(d.count, 8);
                    })
                    .attr('fill', d => colorMap[d.type])
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2)
                    .style('cursor', 'pointer')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended))
                    .on('click', (event, d) => showNodeDetails(d, data))
                    .on('mouseover', function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr('stroke-width', 4)
                            .attr('r', function() {
                                const currentR = parseFloat(d3.select(this).attr('r'));
                                return currentR * 1.3;
                            });
                    })
                    .on('mouseout', function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr('stroke-width', 2)
                            .attr('r', function() {
                                if (d.type === 'malware') return 15 + Math.min(d.count * 2, 15);
                                if (d.type === 'agent') return 12 + Math.min(d.count, 10);
                                return 8 + Math.min(d.count, 8);
                            });
                    });
                
                // Add labels
                const label = g.append('g')
                    .selectAll('text')
                    .data(data.nodes)
                    .enter()
                    .append('text')
                    .text(d => d.label.length > 20 ? d.label.substring(0, 20) + '...' : d.label)
                    .attr('font-size', d => d.type === 'malware' ? '12px' : '10px')
                    .attr('fill', '#e0e0e0')
                    .attr('text-anchor', 'middle')
                    .attr('dy', d => {
                        if (d.type === 'malware') return 35;
                        if (d.type === 'agent') return 25;
                        return 20;
                    })
                    .style('pointer-events', 'none')
                    .style('font-weight', d => d.type === 'malware' ? 'bold' : 'normal');
                
                // Update positions on simulation tick
                graphSimulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    label
                        .attr('x', d => d.x)
                        .attr('y', d => d.y);
                });
                
                // Drag functions
                function dragstarted(event, d) {
                    if (!event.active) graphSimulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) graphSimulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
                
                console.log(`Correlation graph loaded: ${data.nodes.length} nodes, ${data.links.length} links`);
                
            } catch (error) {
                console.error('Failed to load correlation graph:', error);
            }
        }
        
        function showNodeDetails(node, graphData) {
            const detailsPanel = document.getElementById('nodeDetails');
            const detailsTitle = document.getElementById('detailsTitle');
            const detailsContent = document.getElementById('detailsContent');
            
            detailsTitle.textContent = node.label;
            
            let html = `<p><strong>Type:</strong> ${node.type.toUpperCase()}</p>`;
            html += `<p><strong>Occurrences:</strong> ${node.count}</p>`;
            
            // Find connections
            const connections = graphData.links.filter(l => 
                l.source.id === node.id || l.target.id === node.id
            );
            
            if (connections.length > 0) {
                html += `<p><strong>Connections:</strong> ${connections.length}</p>`;
                html += '<ul style="margin: 10px 0; padding-left: 20px;">';
                connections.slice(0, 10).forEach(link => {
                    const otherNode = link.source.id === node.id ? link.target : link.source;
                    html += `<li>${link.type.replace(/_/g, ' ')}: ${otherNode.label}</li>`;
                });
                if (connections.length > 10) {
                    html += `<li>...and ${connections.length - 10} more</li>`;
                }
                html += '</ul>';
            }
            
            if (node.details && node.details.length > 0) {
                html += '<p><strong>Associated Files:</strong></p>';
                html += '<ul style="margin: 10px 0; padding-left: 20px; max-height: 150px; overflow-y: auto;">';
                node.details.slice(0, 10).forEach(file => {
                    html += `<li>${file}</li>`;
                });
                if (node.details.length > 10) {
                    html += `<li>...and ${node.details.length - 10} more</li>`;
                }
                html += '</ul>';
            }
            
            detailsContent.innerHTML = html;
            detailsPanel.style.display = 'block';
        }
        
        function resetGraph() {
            if (graphSimulation) {
                graphSimulation.alpha(1).restart();
            }
        }
        
        function centerGraph() {
            if (graphSvg) {
                graphSvg.transition().duration(750).call(
                    d3.zoom().transform,
                    d3.zoomIdentity
                );
            }
        }
        
        function setChartDays(days) {
            currentChartDays = days;
            
            // Update button states
            document.querySelectorAll('.chart-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            loadDailyChart();
        }
        
        function loadData() {
            loadStats();
            loadScans();
            // Heavy components loaded lazily - see switchView()
        }
        
        function loadDataWithoutMap() {
            loadStats();
            loadScans();
        }
        
        // Track which analytics have been loaded
        let analyticsLoaded = false;
        
        function loadAnalytics() {
            console.log('Loading analytics view...');
            loadDailyChart();
            loadMalwareSources();
            loadNoisyAgentsChart();
            loadSignatureClassChart();
            loadPackerClassChart();
            loadConfidenceHistChart();
            loadEntropyBoxChart();
            loadEmergingThreats();
            loadCorrelationGraph();
            loadGeoMap();
            
            analyticsLoaded = true;
        }
        
        // Initial load - only dashboard essentials
        loadData();
        
        // Auto-scroll functionality with visual indicators
        const scrollIndicatorUp = document.createElement('div');
        scrollIndicatorUp.className = 'scroll-indicator scroll-up';
        scrollIndicatorUp.innerHTML = '<i class="fas fa-chevron-up"></i>';
        document.body.appendChild(scrollIndicatorUp);
        
        const scrollIndicatorDown = document.createElement('div');
        scrollIndicatorDown.className = 'scroll-indicator scroll-down';
        scrollIndicatorDown.innerHTML = '<i class="fas fa-chevron-down"></i>';
        document.body.appendChild(scrollIndicatorDown);
        
        let pageScrollInterval = null;
        const scrollSpeed = 3;
        const triggerZone = 80; // pixels from top/bottom
        
        function handleAutoScroll(event) {
            // Don't auto-scroll if page is hidden
            if (document.hidden) return;
            
            // Don't auto-scroll if hovering over back-to-top button
            const backToTopBtn = document.getElementById('backToTop');
            if (backToTopBtn && backToTopBtn.matches(':hover')) {
                stopAutoScroll();
                return;
            }
            
            const mouseY = event.clientY;
            const windowHeight = window.innerHeight;
            
            // Check if near top
            if (mouseY < triggerZone) {
                scrollIndicatorUp.classList.add('visible');
                scrollIndicatorDown.classList.remove('visible');
                
                if (!pageScrollInterval) {
                    pageScrollInterval = setInterval(() => {
                        if (document.hidden) {
                            stopAutoScroll();
                            return;
                        }
                        window.scrollBy({
                            top: -scrollSpeed,
                            behavior: 'auto'
                        });
                    }, 16); // ~60fps
                }
            }
            // Check if near bottom
            else if (mouseY > windowHeight - triggerZone) {
                scrollIndicatorDown.classList.add('visible');
                scrollIndicatorUp.classList.remove('visible');
                
                if (!pageScrollInterval) {
                    pageScrollInterval = setInterval(() => {
                        if (document.hidden) {
                            stopAutoScroll();
                            return;
                        }
                        window.scrollBy({
                            top: scrollSpeed,
                            behavior: 'auto'
                        });
                    }, 16);
                }
            }
            // In neutral zone
            else {
                scrollIndicatorUp.classList.remove('visible');
                scrollIndicatorDown.classList.remove('visible');
                
                if (pageScrollInterval) {
                    clearInterval(pageScrollInterval);
                    pageScrollInterval = null;
                }
            }
        }
        
        function stopAutoScroll() {
            scrollIndicatorUp.classList.remove('visible');
            scrollIndicatorDown.classList.remove('visible');
            
            if (pageScrollInterval) {
                clearInterval(pageScrollInterval);
                pageScrollInterval = null;
            }
        }
        
        // Attach event listeners
        document.addEventListener('mousemove', handleAutoScroll);
        document.addEventListener('mouseleave', stopAutoScroll);
        
        // Stop scrolling when reaching top or bottom
        let lastScrollTop = 0;
        window.addEventListener('scroll', () => {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollHeight = document.documentElement.scrollHeight;
            const clientHeight = document.documentElement.clientHeight;
            
            // At top
            if (scrollTop === 0 && lastScrollTop > 0) {
                stopAutoScroll();
            }
            // At bottom
            if (scrollTop + clientHeight >= scrollHeight - 5) {
                stopAutoScroll();
            }
            
            lastScrollTop = scrollTop;
        });
        
        // Set up Server-Sent Events for real-time updates
        const eventSource = new EventSource('/api/events');
        let updateDebounceTimer = null;
        let pollingInterval = null;
        let pendingUpdates = false;
        
        eventSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            
            if (data.type === 'connected') {
                console.log('Connected to server for real-time updates');
            } else if (data.type === 'stats' && data.stats) {
                renderStats(data.stats);
            } else if (data.type === 'client-update') {
                if (typeof data.activeClients === 'number') {
                    animateStatCard('stat-clients', data.activeClients);
                }
            } else if (data.type === 'new-scan') {
                console.log('New scan received:', data.scan.detected_filename);
                
                // Show notification toast
                showThreatNotification(data.scan);
                
                // Add to threat ticker
                addToThreatTicker(data.scan);
                
                // Debounce: batch multiple rapid scans into single update
                pendingUpdates = true;
                clearTimeout(updateDebounceTimer);
                updateDebounceTimer = setTimeout(() => {
                    if (pendingUpdates) {
                        // Only reload lightweight data (stats + scan list)
                        loadStats();
                        loadScans();
                        
                        // If analytics view is open, refresh analytics too
                        if (currentView === 'analytics' && analyticsLoaded) {
                            loadAnalytics();
                        }
                        
                        pendingUpdates = false;
                        
                        // Throttle map updates to once per 15 seconds
                        if (!window.lastMapUpdate || Date.now() - window.lastMapUpdate > 15000) {
                            loadGeoMap();
                            window.lastMapUpdate = Date.now();
                        }
                    }
                }, 1000); // Wait 1 second after last scan
            }
        };
        
        eventSource.onerror = function(error) {
            console.error('SSE Error:', error);
            // Fallback: reload data every 30 seconds if SSE connection fails (only once!)
            if (eventSource.readyState === EventSource.CLOSED && !pollingInterval) {
                console.log('SSE connection closed, falling back to polling...');
                pollingInterval = setInterval(() => {
                    loadStats();
                    loadScans();
                }, 30000);
            }
        };
        
        // Manual refresh button functionality
        window.manualRefresh = function() {
            loadData();
        };
    </script>
    
    <!-- Theme Toggle Script -->
    <script>
        // Theme Toggle Functionality
        window.toggleTheme = function() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? '' : 'light';
            
            if (newTheme) {
                html.setAttribute('data-theme', newTheme);
            } else {
                html.removeAttribute('data-theme');
            }
            localStorage.setItem('theme', newTheme || 'dark');
            
            // Update button icon and text
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            
            if (newTheme === 'light') {
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark';
            }
        };
        
        // Load saved theme on page load
        (function() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            if (savedTheme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
            }
            
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            
            if (savedTheme === 'light') {
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark';
            }
        })();
    </script>
</body>
</html>
